#version 460

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

struct ray {
        vec3 pos;
        vec3 dir;
};

struct sphere {
        vec3  ctr;
        float rad;
        vec3  col;
};

struct light {
        vec3  pos;
        float intensity;
};

float intersection_distance(ray r, sphere s) {
        // use determinant to test for intersections
        vec3 omc = s.ctr - r.pos;
        float b = dot(r.dir, omc);
        float a = dot(r.dir, r.dir);
        float c = dot(omc, omc) - (s.rad * s.rad);
        float t = b * b - a * c;
        
        if (t < 0) {
                return -1;
        }

        // nearest root
        return (b - sqrt(t)) / a;
}

void main() {
        // base colour
        vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
        // position of pixel within work group, and by extension, the image
        ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

        float max_x = 5.0;
        float max_y = 5.0;
        // fetch image dimensions, could probably hard code this if we were feeling silly...
        ivec2 dims = imageSize(img_output);
        // times coords by two otherwise we would have to subtract half of width?
        // maps each coordinate to a [-5,5] range
        float x = max_x * (float(pixel_coords.x * 2.0 - dims.x) / dims.x);
        float y = max_y * (float(pixel_coords.y * 2.0 - dims.y) / dims.y);
        
        ray r = ray( vec3(0.0, 0.0, 0.0), vec3(x, y, -1.0) );

        sphere objects[2];
        objects[0] = sphere( vec3(0.0, 0.0, -2.0), 1.0, vec3(0.4, 0.4, 1.0) );
        objects[1] = sphere( vec3(5.0, 0.0, -5.0), 3.0, vec3(0.4, 1.0, 0.2) );

        // find intersection
        float nearest = 100.0;
        int nearest_index = -1;
        for (int i = 0; i < 2; ++i) {
                float dist = intersection_distance(r, objects[i]);
                if (dist < 0) {
                        continue;
                } else if (dist < nearest) {
                        nearest = dist;
                        nearest_index = i;
                }
        }
        
        if (nearest_index < 0) {
                pixel = vec4(0.1, 0.1, 0.1, 1.0);
        } else {
                pixel = vec4(objects[nearest_index].col, 1.0);
        }

        // output pixel
        imageStore(img_output, pixel_coords, pixel);
}